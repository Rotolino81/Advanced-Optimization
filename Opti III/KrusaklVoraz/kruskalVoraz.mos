model Kruskal
    forward procedure ReadDataFile(filename: string)
    forward function argmin: integer
    forward procedure UpdateF
    
    declarations
        V: set of integer !Conjunto de vértices o nodos
        edges = record  !Tipo de dato arista
            i: integer !Primer nodo de la arista
            j: integer !Segundo nodo de la arista
            cost: real !Costo de la arista
        end-record
        g: array(V) of integer
        E: dynamic array(range) of edges !Arreglo de las aristas del grafo
        f: real !Valor de la función objetivo 
        F: set of integer !Conjunto de elementos factibles
        S: dynamic array(range) of edges !Aristas del árbol generador
        filename: string !Nombre del archivo de datos
        n: integer !numero de nodos
        d: dynamic array(range, range) of real
        edgestar: integer !Índice de la arista seleccionada
        Sedges: integer !Índice en el arreglo de aristas del árbol
    end-declarations
    
    writeln("Data file name: ")
    read(filename)
    
    ReadDataFile(filename)
    
    declarations
        label: array(V) of integer !Arreglo de etiquetas de las componente conexas
    end-declarations
    
    ! Inicialización
    forall(i in V) do
        label(i) := i
        g(i) := 0  ! Inicializar grados en 0
    end-do
    
    f := 0
    F := {1..getsize(E)}
    Sedges := 0
    
    writeln("Aristas del arbol generador")
    while(Sedges<n) do  ! Control de n-1 aristas
        edgestar := argmin
        g(E(edgestar).i) += 1
        g(E(edgestar).j) += 1
        Sedges := Sedges + 1
        S(Sedges) := E(edgestar)
        writeln("{",S(Sedges).i,",",S(Sedges).j,"} con costo ",S(Sedges).cost)
        f := f + S(Sedges).cost
        UpdateF
    end-do
    
    writeln("Objective function value: ", f)
    
    procedure ReadDataFile(f: string)
        declarations
            edge: edges !arista
            nbedges: integer !número total de aristas
        end-declarations
        
        fopen(f, F_INPUT)
        nbedges := 0
        read(n)
        forall(i, j in 1..n | i<j) do
            read(d(i,j))
            edge.i := i
            edge.j := j
            edge.cost := d(i,j)
            nbedges := nbedges + 1
            E(nbedges) := edge
            V := V + {edge.i,edge.j}
        end-do
        fclose(F_INPUT)
    end-procedure
    
    function argmin: integer
        declarations
            mincost: real
            kstar: integer
        end-declarations
        
        mincost := MAX_REAL
        forall(k in F) do
            if E(k).cost < mincost then
                mincost := E(k).cost
                kstar := k
            end-if
        end-do
        returned := kstar            
    end-function
    
    procedure UpdateF
        declarations
            S: set of integer
            l: integer
        end-declarations
        
        l := label(E(edgestar).j)
        forall(j in V) do
            if label(j) = l then
                label(j) := label(E(edgestar).i)
            end-if
        end-do
        S := F
        F := {}
     
        forall(k in S) do
            if (g(E(k).i)<2) and (g(E(k).j)<2) then
                if (label(E(k).i)<>label(E(k).j)) or (Sedges=n-1) then
                    F:=F+{k}
                end-if
            end-if
        end-do
    end-procedure
end-model